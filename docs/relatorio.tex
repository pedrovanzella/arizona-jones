\documentclass[12pt]{article}
\usepackage[T1]{fontenc}
\usepackage{algorithm2e}
\usepackage{dot2texi}

\usepackage{tikz}
\usetikzlibrary{shapes,arrows}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\newenvironment{lyxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
 \setlength{\leftmargin}{\labelwidth}
 \addtolength{\leftmargin}{\labelsep}
 \renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{sbc-template}

\usepackage[brazil]{babel}
\usepackage[utf8]{inputenc}

\sloppy

\title{Arizona Jones}

\author{Pedro Vanzella\inst{1}}

\address{Faculdade de Informática -- Pontifícia Universidade Católica do Rio
Grande do Sul (PUCRS) \\ Av. Ipiranga, 6681 - Porto Alegre / RS / Brasil
    \email pedro@pedrovanzella.com}

\makeatother

\usepackage{babel}
\usepackage{listings}
\lstset {
    mathescape,
    frame=none
}
\renewcommand{\lstlistingname}{Listagem}

\begin{document}

\maketitle
\begin{abstract}
  A solution for the Arizona Jones in the Tel Dor Temple is proposed.
\end{abstract}
\begin{resumo}
  Uma solu\c{c}ão para o problema do Arizona Jones no Templo de Tel Dor é proposta.
\end{resumo}


\section{Introdução}\label{sec:intro}

O problema a ser resolvido consiste em encontrar, dentro de um conjunto de números, a maior seqüência crescente de números que, em base 6, têm somente um dígito de diferen\c{c}a entre um e outro.

Por exemplo, no conjunto $782$ $229$ $446$ $527$ $874$ $19$ $829$ $70$ $830$ $992$ $430$ $649$, a maior seqüência é $649$ $829$ $830$.

\section{Estruturas de Dados}\label{sec:estruturas}
Vamos representar o conjunto de números como um grafo. Isto nos permitirá ligar os nodos que formam seqüências válidas e caminhar pelo grafo procurando o maior caminho entre todos.

Para representar internamente o grafo, utilizamos três dicionários: um dicionário para nodos, um para vértices e um para o peso dos nodos. Este último será explicado em detalhe na se\c{c}ão~\ref{sec:algoritmos:achar-maior-caminho}.

O dicionário de nodos tem uma propriedade interessante: seu índice é o número em base 10, como foi lido do arquivo; seu conteúdo é a representa\c{c}ão em base 6 do mesmo número, como um array de dígitos, para facilitar a compara\c{c}ão.

Este grafo é dirigido e acíclico. Isto fica óbvio quando pensamos nos parâmetros do problema: se, para criar uma aresta, precisamos ligar um nodo a alguém maior que ele, não podemos ter ciclos (i.e. A não pode ser maior que B ao mesmo tempo que B é maior que A). Como veremos na se\c{c}ão~\ref{sec:algoritmos:achar-maior-caminho}, isto é muito bom para nós.

% TODO: EXPLICAR ISTO!
%O grafo é dirigido e acíclico, então o algoritmo de encontrar o maior caminho é O(n): https://en.wikipedia.org/wiki/Longest_path_problem

Podemos ver na Figura~\ref{fig:testeprof} um grafo gerado de acordo com o exemplo dado na se\c{c}ão~\ref{sec:intro}

\begin{figure}[h!]
    \begin{dot2tex}[neato,options=-tmath]
        \input{testeprof.dot}
    \end{dot2tex}
    \caption{Exemplo de grafo}
    \label{fig:testeprof}
\end{figure}


\section{Algoritmos}\label{sec:algoritmos}
Para resolver o problema, dividiu-se o programa em diferentes fun\c{c}ões, para facilitar a leitura e explica\c{c}ão.

\subsection{Criar Nodos}\label{sec:algoritmos:criar-nodos}
Esta fun\c{c}ão é trivial: lê-se cada linha do arquivo e adiciona-se ela ao dicionário de nodos
\begin{lstlisting}
criar_nodos(arquivo):
   para cada linha l em arquivo:
      nodos[l] = []
      pesos[l] = 0
\end{lstlisting}

Onde {\sf []} é um \textsf{array} vazio. Este array, nesta implementa\c{c}ão, conterá a representa\c{c}ão em base 6 do seu índice correspondente. Isto é feito para memorizar a conversão, já que este valor poderá ser testado várias vezes pelo algoritmo descrito na sessão~\ref{sec:algoritmos:compara}.
Veja que também inicializamos uma posi\c{c}ão no dicionário de pesos. Este peso será atualizado pelo algoritmo descrito na sessão~\ref{sec:algoritmos:calcula-tamanho-caminhos}.

\subsection{Comparar}\label{sec:algoritmos:compara}

\subsection{Calcular Tamanho do Caminho}\label{sec:algoritmos:calcula-tamanho-caminho}

\subsection{Achar Maior Caminho}\label{sec:algoritmos:achar-maior-caminho}

\section{Resultados}\label{sec:resultados}
Obviamente o algoritmo é ruim. Mas quão ruim? Seria possível resolver o problema para uma entrada razoavel? A fim de curiosidade, o algorítmo foi implementado e os resultados podem ser vistos na Tabela~\ref{tab:resultados-1}.

\begin{table}[h]
\caption{Primeira Tentativa}
\label{tab:resultados-1}
\begin{tabular}{ll}
  {\sf num} & Tempo (s) \\
  \hline
  2 & 0.01 \\
  3 & 0.01 \\
  4 & 0.01 \\
  5 & 0.02 \\
  6 & 0.09 \\
  7 & 1.25 \\
  8 & 23.9 \\
  9 & 540.9    
\end{tabular}
\end{table}



\end{document}
