\documentclass[12pt]{article}
\usepackage[T1]{fontenc}
\usepackage{algorithm2e}
\usepackage{dot2texi}

\usepackage{tikz}
\usetikzlibrary{shapes,arrows}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\newenvironment{lyxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
 \setlength{\leftmargin}{\labelwidth}
 \addtolength{\leftmargin}{\labelsep}
 \renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{sbc-template}

\usepackage[brazil]{babel}
\usepackage[utf8]{inputenc}

\sloppy

\title{Arizona Jones}

\author{Pedro Vanzella\inst{1}}

\address{Faculdade de Informática -- Pontifícia Universidade Católica do Rio
Grande do Sul (PUCRS) \\ Av. Ipiranga, 6681 - Porto Alegre / RS / Brasil
    \email pedro@pedrovanzella.com}

\makeatother

\usepackage{babel}
\usepackage{listings}
\lstset {
    mathescape,
    frame=none
}
\renewcommand{\lstlistingname}{Listagem}

\begin{document}

\maketitle
\begin{abstract}
  A solution for the Arizona Jones in the Tel Dor Temple is proposed.
\end{abstract}
\begin{resumo}
  Uma solu\c{c}ão para o problema do Arizona Jones no Templo de Tel Dor é proposta.
\end{resumo}


\section{Introdução}\label{sec:intro}

O problema a ser resolvido consiste em encontrar, dentro de um conjunto de números, a maior seqüência crescente de números que, em base 6, têm somente um dígito de diferen\c{c}a entre um e outro.

Por exemplo, no conjunto $782$ $229$ $446$ $527$ $874$ $19$ $829$ $70$ $830$ $992$ $430$ $649$, a maior seqüência é $649$ $829$ $830$.

\section{Estruturas de Dados}\label{sec:estruturas}
Vamos representar o conjunto de números como um grafo. Isto nos permitirá ligar os nodos que formam seqüências válidas e caminhar pelo grafo procurando o maior caminho entre todos.

Para representar internamente o grafo, utilizamos três dicionários: um dicionário para nodos, um para vértices e um para o peso dos nodos. Este último será explicado em detalhe na se\c{c}ão~\ref{sec:algoritmos:achar-maior-caminho}.

O dicionário de nodos tem uma propriedade interessante: seu índice é o número em base 10, como foi lido do arquivo; seu conteúdo é a representa\c{c}ão em base 6 do mesmo número, como um array de dígitos, para facilitar a compara\c{c}ão.

Este grafo é dirigido e acíclico. Isto fica óbvio quando pensamos nos parâmetros do problema: se, para criar uma aresta, precisamos ligar um nodo a alguém maior que ele, não podemos ter ciclos (i.e. A não pode ser maior que B ao mesmo tempo que B é maior que A). Como veremos na se\c{c}ão~\ref{sec:algoritmos:achar-maior-caminho}, isto é muito bom para nós.

% TODO: EXPLICAR ISTO!
%O grafo é dirigido e acíclico, então o algoritmo de encontrar o maior caminho é O(n): https://en.wikipedia.org/wiki/Longest_path_problem

Podemos ver na Figura~\ref{fig:testeprof} um grafo gerado de acordo com o exemplo dado na se\c{c}ão~\ref{sec:intro}

\begin{figure}[h!]
    \begin{dot2tex}[neato,options=-tmath]
        \input{testeprof.dot}
    \end{dot2tex}
    \caption{Exemplo de grafo}
    \label{fig:testeprof}
\end{figure}


\section{Algoritmos}\label{sec:algoritmos}
Para resolver o problema, dividiu-se o programa em diferentes fun\c{c}ões, para facilitar a leitura e explica\c{c}ão.

\subsection{Criar Nodos}\label{sec:algoritmos:criar-nodos}
Esta fun\c{c}ão é trivial: lê-se cada linha do arquivo e adiciona-se ela ao dicionário de nodos
\begin{lstlisting}
criar_nodos(arquivo):
   para cada linha l em arquivo:
      nodos[l] = []
      pesos[l] = 0
\end{lstlisting}

Onde {\sf []} é um \textit{array} vazio. Este array, nesta implementa\c{c}ão, conterá a representa\c{c}ão em base 6 do seu índice correspondente. Isto é feito para memorizar a conversão, já que este valor poderá ser testado várias vezes pelo algoritmo descrito na sessão~\ref{sec:algoritmos:comparar}.
Veja que também inicializamos uma posi\c{c}ão no dicionário de pesos. Este peso será atualizado pelo algoritmo descrito na se\c{c}ão~\ref{sec:algoritmos:calcular-tamanho-caminhos}.

\subsection{Criar Arestas}\label{sec:algoritmos:criar-arestas}
O algoritmo de criar arestas itera pelos nodos, conectando aqueles que podem formar uma seqüência válida para o problema.
\begin{lstlisting}
criar_arestas():
   para todo u em nodos:
      para todo v maior que u em nodos:
         se comparar(u, v):
            arestas[u,v] = Verdadeiro
\end{lstlisting}

Há uma chamada para o algoritmo {\sf comparar()}, que é explicado na se\c{c}ão~\ref{sec:algoritmos:comparar}.
Não é necessário testar todos os nodos contra todos, no entanto. Como somente seqüências crescentes podem ser geradas, filtramos {\sf v} para ser maior que {\sf u}.
O conteúdo do dicionário de arestas não é importante. O valor dele pode, portanto, ser qualquer um.

\subsection{Comparar}\label{sec:algoritmos:comparar}
Esta fun\c{c}ão compara dois índices, {\sf u} e {\sf v}, retornando um booleano que indica se {\sf u} pode ser ligado a {\sf v} através de uma aresta.
\begin{lstlisting}
comparar(u, v):
   se v < u:
      retorna Falso

   bsu = base6(u)
   bsv = base6(v)

   digitos_diferentes = 0

   se len(bsv) - len(bsu) > 1:
      retorna Falso

   bsu = pad(bsu, lenght(bsv))

   para i de lenght(bsv) a 0:
      se bsu[i] != bsv[i]:
         digitos_diferentes += 1
      se digitos_diferentes > 1
         retorna Falso

   retorna Verdadeiro
\end{lstlisting}

Aqui vemos uma chamada para a fun\c{c}ão {\sf base6()}, que será explicada na se\c{c}ão~\ref{sec:algoritmos:base6}.
Há também uma chamada para {\sf pad()}. Esta fun\c{c}ão apenas adiciona zeros à esquerda de seu primeiro argumento até que ele fique com o tamanho de seu segundo argumento. Isto nos permite testar números que têm uma quantidade de dígitos diferentes.
Como um número pode diferir de outro em um dígito quando representados em base 6, temos duas op\c{c}ões: todos os dígitos são iguais, mas um dígito novo é adicionado à esquerda do menor (\textit{e.g.} $231_6$ e $1231_6$) ou a quantidade de dígitos é a mesma, mas apenas um dígito é diferente entre ambos os números (\textit{e.g.} $231_6$ e $232_6$).

O algoritmo também verifica se {\sf v} é maior que {\sf u}. Esta é um teste de sanidade apenas, já que o algoritmo de Criar Arestas (se\c{c}ão~\ref{sec:algoritmos:criar-arestas} só chama o algoritmo de Comparar para {\sf v}s maiores que {\sf u}.

Outra verifica\c{c}ão é feita antes de se testar todos os dígitos, comparando os tamanhos dos dois \textit{arrays} de números em base 6. Se a diferen\c{c}a é maior que 1, há garantidamente mais que um dígito diferente também, e estes nodos não podem ser conectados. Esta verifica\c{c}ão é interessante porque pode rodar em tempo constante, dependendo de como a linguagem representa \textit{arrays}. Em uma linguagem como C, no entanto, não há vantagem.

Após estas verifica\c{c}ões, itera-se pelo maior \textit{array} (que é garantidamente {\sf bsv}, já que {\sf v} é maior que {\sf u}), comparando dígito a dígito, do final para o início, com {\sf bsu}. Caso mais que um dígito diferente seja encontrado, a verifica\c{c}ão pára e retorna-se Falso, para indicar que os nodos não podem ser conectados por uma aresta.

\subsection{Converter para Base 6}\label{sec:algoritmos:base6}
A conversão para base 6 em si não é importante - ela pode ser realizada por uma fun\c{c}ão de alguma biblioteca, ou manualmente com matemática simples. O que é importante aqui é a memoriza\c{c}ão do resultado.
\begin{lstlisting}
base6(num):
   se nodos[num] == []:
      nodos[num] = Conversor.ConverteBase(6, num)
   retorna nodos[num]
\end{lstlisting}

Vemos aqui uma chamada para uma biblioteca arbitrária que faz a conversão e retorna um \textit{array} de inteiros, dígito a dígito. Mas isto somente é feito caso {\sf nodos[num]} seja um \textit{array} vazio ({\sf []}). Ele não ser vazio significa que {\sf base6()} já foi chamada nele, e seu conteúdo é a representa\c{c}ão em base 6 de sua chave.

\subsection{Calcular Tamanho do Caminho}\label{sec:algoritmos:calcular-tamanho-caminhos}
O dicionário de pesos tem como chaves os nomes dos nodos, e como valores o tamanho do maior caminho que vai até ele.
Para calcular este valor, olha-se todos os vizinhos que chegam em um nodo {\sf u}. O valor do nodo {\sf u} é o valor do seu maior vizinho, mais um. Caso ninguém chegue em {\sf u}, seu valor é zero.
Isto será crucial para encontrarmos o maior caminho na se\c{c}ão~\ref{sec:algoritmos:achar-maior-caminho}.
\begin{lstlisting}
calcular_tamanho_caminho(u):
   para todo v em vizinhos_que_chegam(u):
      se pesos[v] == 0:
         pesos[v] = calcular_tamanho_caminho(v) + 1
      se pesos[v] > pesos[u]:
         pesos[u] = pesos[v] + 1

   retorna pesos[u]
\end{lstlisting}

O algoritmo {\sf vizinhos\_que\_chegam()} é explicado na se\c{c}ão~\ref{sec:algoritmos:vizinhos-que-chegam}.

% TODO: explicar melhor isto aqui

\subsection{Vizinhos que Chegam}\label{sec:algoritmos:vizinhos-que-chegam}
Este algoritmo tem como fun\c{c}ão encontrar todos os nodos que têm uma aresta que os conectam em {\sf u}.
\begin{lstlisting}
vizinhos_que_chegam(u):
   lista = []
   para todo v em nodos:
      se existe_aresta(v, u):
         lista.add(v)

   retorna lista
\end{lstlisting}

Observe que {\sf existe\_aresta()} é chamado com os parâmetros invertidos, isto é, se existe uma aresta de {\sf v} para {\sf u}.
Uma lista de nodos é montada e retornada, contendo todos os nodos que possuem uma aresta para {\sf u}.

% TODO: explicar melhor, talvez?

\subsection{Achar Maior Caminho}\label{sec:algoritmos:achar-maior-caminho}

\section{Resultados}\label{sec:resultados}
Obviamente o algoritmo é ruim. Mas quão ruim? Seria possível resolver o problema para uma entrada razoavel? A fim de curiosidade, o algorítmo foi implementado e os resultados podem ser vistos na Tabela~\ref{tab:resultados-1}.

\begin{table}[h]
\caption{Primeira Tentativa}
\label{tab:resultados-1}
\begin{tabular}{ll}
  {\sf num} & Tempo (s) \\
  \hline
  2 & 0.01 \\
  3 & 0.01 \\
  4 & 0.01 \\
  5 & 0.02 \\
  6 & 0.09 \\
  7 & 1.25 \\
  8 & 23.9 \\
  9 & 540.9    
\end{tabular}
\end{table}



\end{document}
